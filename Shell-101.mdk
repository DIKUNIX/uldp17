# Shell 101 { #sec-shell }

Dear to the heart of a Unix-like operating system is a command-line interface
with the operating system, often referred to as a "shell", or "terminal".

A [Command-Line Interface
(CLI)](https://en.wikipedia.org/wiki/Command-line_interface) interprets textual
commands (rather than mouse clicks, gestures, and alike). To this end, a CLI
presents you with a "line" where you can enter text, and hereby "prompts" you
to enter a command.

You can then type away at the keyboard, and hit the Enter key to "enter" a
command. The CLI responds by trying to interpret your command, and if the
command makes sense, by executing it. This execution may, or may not have a
directly observable effect. If the execution terminates, you will be presented
with another prompt, prompting for the next command.

The shell typically also has a [Text-based User Interface
(TUI)](https://en.wikipedia.org/wiki/Text-based_user_interface), meaning that
if there is something to tell, it will do so by means of text. It is important
for a user-friendly experience that the utilities you use in your shell have
good text-formatting defaults and options.

When first logging in on a headless Unix-like machine, you are greeted with a
welcome message and a prompt. For example, when logging in our machine, you are
greeted as follows:

```
Welcome to syrakuse.
Happy hacking!
alis@syrakuse:~$
```

In place of `alis` however, you will see the username you logged in with.

Try pressing enter a couple times,

```
Welcome to syrakyse.
Happy hacking!
alis@syrakuse:~$
alis@syrakuse:~$
alis@syrakuse:~$
alis@syrakuse:~$
```

This is how you "enter" the commands for this computer to execute.

The empty command is a little silly, so let's try something (slightly) less
silly:

```
alis@syrakuse:~$ 42
-bash: 42: command not found
alis@syrakuse:~$ hello
-bash: hello: command not found
alis@syrakuse:~$ cowsay hello
 _______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
alis@syrakuse:~$
```

`bash` here is the program that interprets your commands: `bash` here is your
"shell".  `42` and `hello` are not commands that this computer understands, but
it understands `cowsay`. `cowsay` is a classic, silly little game we've put on
this machine.

## The Prompt { #sec-shell-prompt }

The line

```
alis@syrakuse:~$
```

is called a "prompt". This prompt shows the username you logged in with (in
this case, `alis`), the hostname of the machine you logged in on (in this case,
`syrakuse`), and the working directory of your shell (in this case, `~`).

In the remainder of this document, we won't point out the username and
hostname, as we do not intend on changing users or machines. Going forth, our
prompts will simply look like this:

```
~$
```

## The Working Directory { #sec-shell-wd }

All major operating systems (both Unix-like and Windows) are centered around
the idea of the user working with directories and files: a *file system*. In
practice, this has two aspects:

1. every user has a some sort of a *home directory*; and
2. every program is working from the point of view of a particular directory:
its *working directory*.

When you login on our machine, you land in a `bash` program, whose working
directory is the home directory of the user you logged in with. The user's home
directory has the alias `~` on Unix-like systems.

The following sections show how you can figure out what your working directory
is, how to navigate the file system, create new directories, and change the
working directory of `bash`.

## `pwd`, `mkdir` and `ls` { #sec-shell-pwd-mkdir-ls }

`pwd` prints the working directory:

```
~$ pwd
/home/alis
~$
```

In Unix-like operating systems, file system paths are separated by `/` (forward
slash). (In Windows, they are separated by `\` (backward slash).) Furthermore,
in Unix-likes systems, unlike in Windows, all directories and files reside in
one file system, starting at `/`. This is called the *root directory*.

In this case, we see that the root directory has one subdirectory `home`, which
has a sub-subdirectory `alis`. This is `alis`'s home directory. So `~` (in
`alis`'s case) is really an alias for `/home/alis`. Let's make a mess of our
home directory by attempting to map the world.

`mkdir` can create new directories:

```
~$ mkdir Europe
~$ mkdir Africa
~$ mkdir Antarctica Asia  Australia
~$ mkdir "North America" "South America"
```

`ls` can list directory contents:

```
~$ ls
 Africa   Antarctica   Asia   Europe  North America  South America
```

This is a little cryptic. How many directories do we actually have? To get a
line-by-line directory listing, with one entry per line, we can pass in the
argument `-l` to `ls`, where the `l` (small L) *flag* stands for "long".

```
~$ ls -l
total 28
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Africa
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Antarctica
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Asia
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Australia
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Europe
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 North America
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 South America
```

This lists quite a number of additional details, which we explore below. First
of all, you can now count the directories by (manually) counting the number of
lines that start with a `d`.

Counting the lines, we see that the above `mkdir` commands created 7
directories. This suggests how the shell chooses to split up the arguments to
`mkdir`. For instance, the following command:

```
~$ mkdir Antarctica Asia  Australia
```

Created 3 directories: `Antarctica`, `Asia`, and `Australia`: the shell splits
command arguments at one or more space characters.

If you want to put a space in your argument (e.g., to create a directory with
spaces in its name), you must put the argument in quotes, as we did with the
following `mkdir` command:

```
~$ mkdir "North America" "South America"
```

This created 2 directories: `North America` and `South America`.

Another way to avoid the shell splitting up your argument is to *escape* the
spaces.  Escaping is done by putting a special `\` (back slash) character in
front of the character you want "escaped". Some other characters that we often
escape are `"` (double quote), and `\` (backslash) itself. The following
`mkdir` command is equivalent to the above:

```
~$ mkdir North\ America South\ America
```

By default, `ls` will sort the entries alphabetically. `ls` supports multiple
orderings out of the box. For instance, you can order the entries by
modification time, in reverse chronological order, using the `t` flag:

```
~$ ls -lt
total 28
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 North America
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 South America
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Antarctica
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Asia
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Australia
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Africa
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Europe
```

Although the *long* listing does not show an offset in terms of creation time,
we can verify this against our command history above. If you are not convinced,
or happened to enter the above `mkdir` commands in a different order, you can
use the `history` built-in:

```
~$ history
...
  562  mkdir Europe
  563  mkdir Africa
  564  mkdir Antarctica Asia  Australia
  565  mkdir "North America" "South America"
  566  ls
  567  ls -l
  568  ls -lt
  569  history
~$
```

Your shell keeps your recent command history, and the `history` built-in allows
you to see it. Notably, `history` is not a standard utility, and so might be
absent from some shells you might find elsewhere.

More frequently however, you want to go through your command history in order
to fix, repeat, or extend a command. To this end, you can use the arrow keys to
cycle through the most-recent commands.

By default, `ls` lists the contents of the working directory. It can also be
used to list the contents of other directories.

Try typing `ls E` and press TAB. The shell will expand this to `ls Europe/`
(the trailing `/` indicates that `Europe` is a directory):

```
~$ ls Europe/
~$
```

(The `Europe` directory is empty.)

Try typing `ls A` and press TAB. In this case, the shell cannot unambiguously
expand to a particular directory name, and instead lists the directories that
start with `A`. Continue by tying `f` and press TAB again. The shell will now
complete the name for you to `ls Africa/`.

> **TIP** Your shell is on good terms with your file system. When specifying a
> path, your shell can see the files and directories in your system, and help
> you type them out quickly and correctly. Use "tab completion".

Unlike with the file system, there is typically less collaboration between your
shell and your programs. Your shell will not help you remember cryptic
arguments like `-lt` to `ls`. (To this end, you can introduce aliases. More
about aliases later.)

Let us now create some sub-directories to work with (remember to try out the
tab and arrow keys!):

```
~$ mkdir Europe/Denmark
~$ mkdir Europe/Germany
~$ mkdir Europe/France
~$ mkdir Europe/Denmark/Copenhagen
~$ mkdir Europe/Germany/Berlin
~$ mkdir Europe/France/Paris
~$ ls -l Europe
total 12
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Denmark
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Germany
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 France
```

### Exercises

1. List the contents of the `/` directory.
2. List the contents of the `/home/` directory.
3. Create the directory `~/1/1/2/3/5/8/13/21`.
4. Create the directory `"hello,\ shell"` in your home directory.

   **NB!** `ls -l` should show something like this:
   ```
   ~$ ls -l
   ...
   drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 "hello,\ shell"
   ...
   ```

## `cd` { #sec-shell-cd }

`cd` changes the current working directory:

```
~$ cd Europe
~/Europe$ ls -l
total 12
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Denmark
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 Germany
drwxr-xr-x 2 alis alis 4096 Sep 21 13:37 France
~/Europe$
```

It is convenient that the shell's prompt lets you know where you stand. It
almost makes it irrelevant to know the command `pwd`, as long as you know what
`~` means.

`cd` with no arguments will lead you back home:

```
~/Europe$ cd
~$
```

Of course, you can also use the path alias `~`:

```
~$ cd Europe
~/Europe$ cd ~
~$
```

Let's go deeper:

```
~$ cd Europe/Denmark
~/Europe/Denmark$
```

Every directory has a special directory `..`

If you `cd` to `..` you go "up" a directory in the file system hierarchy. We
say that `..` refers to the *parent directory*. So here's the long way home:

```
~/Europe/Denmark$ cd ../../
~$
```

If every directory has a special directory `..` then how come we didn't see it
in our directory listings above? This is because Unix-like convention has it
that hidden files and directories start with a `.` (dot). Of course, there is
nothing overly special about "hidden" files (on Unix-like systems or Windows).
We can get `ls` to show *all* the directories in a directory using an
additional `a` flag:

```
~$ ls -lah
total 40K
drwxr-xr-x 10 alis alis 4.0K Sep 21 13:37 .
drwxr-xr-x  3 alis alis 4.0K Sep 21 13:37 ..
drwxr-xr-x  3 alis alis 4.0K Sep 21 13:37 1
drwxr-xr-x  4 alis alis 4.0K Sep 21 13:37 Africa
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 Antarctica
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 Asia
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 Australia
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 "hello,\ shell"
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 Europe
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 North America
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 South America
~$
```

`.` is also special directory, it refers to the *current directory*.

### Exercises

1. `cd ~/../../../../../../` Where do you end up?
2. Go back home.
3. `cd ~/./../alis/Europe/./Denmark/../../` Where do you end up?
4. Create a hidden directory in your home directory.

## `echo`, `cat`, and `>` { #sec-shell-echo-cat-redirect }

`echo` is a program that can display a line of text. For instance:

```
~$ echo "Roses are red,"
Roses are red,
~$
```

Note, again how arguments containing spaces are surrounded by double quotes.

At first sight, `echo` is a rather useless program. This is where the power of
a Unix-like operating system comes into play: your shell can *redirect* the
output from a program to a file. To do this, follow the command by the a `>`
(output redirection) character, followed by a path to the file where you want
the output.

```
~$ echo "Roses are red," > roses.txt
~$
```

We can use `ls` to check to see what happened:

```
~$ ls -lah
...
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 "hello,\ shell"
-rw-r--r--  1 alis alis   15 Sep 21 13:37 roses.txt
drwxr-xr-x  2 alis alis 4.0K Sep 21 13:37 Lynx
...
~$
```

So now there is something called `roses.txt` in our home directory. Unlike the
directories we created before, the left-most character printed by `ls` is a `-`
(dash), rather than a `d`. This indicates that `roses.txt` is *not* a
directory.

`cd` can help us verify this:

```
~$ cd roses.txt
bash: cd: roses.txt: Not a directory
```

> **TIP** Sometimes, all you want to do is inspect the filesystem attributes of
> a given file. To do this, just pass in the path as an argument to `ls`:
>
> ```
> ~$ ls -lah roses.txt
> -rw-r--r--  1 alis alis   15 Sep 21 13:37 roses.txt
> ```

`cat` is a program that can print the contents of a file directly inside the
shell:

```
~$ cat roses.txt
Roses are red,
~$
```

Let's create another file:

```
~$ echo "Violets are blue," > violets.txt
~$
```

> **NB** `>` will overwrite the file if it already exists.

`cat` can also *concatenate* files, and print the contents inside the shell:

```
~$ cat roses.txt violets.txt
Roses are red,
Violets are blue,
~$
```

Of course, we can redirect the output of any command, so we can store this,
more complete poem in `poem.txt`.

```
~$ cat roses.txt violets.txt > poem.txt
~$ cat poem.txt
Roses are red,
Violets are blue,
~$
```

### Exercises

1. Create a file `sugar.txt` with the line `Sugar is sweet,`
2. Create a file `you.txt` with the line `And so are you.`
3. Complete the poem in `poem.txt` by combining `roses.txt`, `violets.txt`,
`sugar.txt`, and `you.txt` (in that order).

It should be possible to do this in the end:

```
~$ cat poem.txt
Roses are red,
Violets are blue,
Sugar is sweet,
And so are you.
~$ cat violets.txt you.txt
Violets are blue,
And so are you.
~$
```

## `wc` and `|` { #sec-shell-wc-pipe }

`wc` prints the line, word, and byte count of a file.

```
~$ wc poem.txt
 4 13 65 poem.txt
~$
```

So our poem is 4 lines, 13 words, or 65 bytes in length.

> **TIP** This explains the `65` in the output of `ls -lah` for `poem.txt`:
>
> ```
> ~$ ls -lah poem.txt
> -rw-r--r-- 1 alis alis 65 Sep 21 13:37 poem.txt
> ```

The name `wc` is easy to remember if you think that it stands for "word count",
although the program can do fair a bit more than that. In fact, it isn't even
that good at counting words. Any sequence of non-whitespace characters is
counted as a word. For instance, numbers are also counted as words. Your
high-school teacher would not be happy with such a word count.

> **TIP** If you *just* want the line count for a file, use the `-l` option.
>
> ```
> ~$ wc -l poem.txt
> 4 poem.txt
> ~$
> ```

What if we wanted a word count of a silly little poem like this?

```
~$ cat violets.txt you.txt
Violets are blue,
And so are you.
~$
```

We could use output redirection to put the silly poem in a silly file, pass the
filename to `wc`, and finally remove the silly file (more on this below); but
this would indeed be rather *silly*: Why create a file in the first place?

We can *pipe* the output of one program as input to another. To do this, type
the first command, a `|` (pipe) character, then the second command:

```
~$ cat violets.txt you.txt | wc
      2       7      34
```

`wc` with no arguments, counts the lines, words, and bytes passed to it via the
pipeline. Now `wc` does not print a file name: There is no filename to print!

The silly poem is just 2 lines, 7 words, or 34 bytes in length.

Let's verify that this "pipe"-thing works by doing this with `poem.txt`:

```
~$ cat poem.txt | wc
      4      13      65
```

Except for the silly whitespace (more on how to handle this later), and the
missing filename, the output is the same as with `wc poem.txt` above.

### Exercises

1. Count the number of files and directories directly under the `/` directory.
2. Count the number of users on the system. (Hint: Recall what `~` is an alias
   for.)

## `rm` { #sec-shell-rm }

By now we've made a great big mess of our home directory. It is time to clean
up a little bit. The `rm` command can be used to quickly delete files and folders.

> **NB!** Files and directories removed using `rm` are nearly impossible to
> recover. `rm` is quick-and-dirty: It takes no backups, and cannot be undone.
> It also "removes" file-system entries by simply letting the file-system
> forget the location of the data on disk. Hence, it is sometimes *possible* to
> recover the data by scanning the raw disk device, but the general advice is:
> **measure twice, cut once**.

For instance, to delete the little poem we had:

```
~$ rm poem.txt
~$
```

We can use `ls` to verify that `poem.txt` indeed is gone:

```
~$ ls poem.txt
ls: cannot access poem.txt: No such file or directory
```

If you want to delete directories, you will need to specify the argument `-r`,
where the `r` flag stands for "recursive".

```
~$ rm -r 1/
```

If you want to delete all the files and directories in a directory, but the
directory itself, you can use a wildcard `*` after the directory name:

```
~$ rm -rf Europe/*
~$ ls -lah Europe/
total 8.0K
drwxr-xr-x  2 alis alis 4.0K Sep 19 14:58 .
drwxr-xr-x 10 alis alis 4.0K Sep 19 14:38 ..
~$
```

### Exercises

1. Remove all the files and directories in your home directory which you don't
want to keep for future reference. (Don't remove the `1` directory, we will use
them shortly.)

## `nano` { #sec-shell-nano }

Although we can read and write files using our various command-line utilities,
in conjunction with clever shell tricks, this mode of operation can get a
little cumbersome. Text-editors are dedicated utilities to this end.

There are two classical text-editors in a Unix-like environment: `vim` and
`emacs`. The users of one are often viciously dispassionate about the users of
the other.  More humble users use whatever suits the task at hand. For
instance, `vi` (a slimmer, older version of `vim`) is available on most systems
out of the box, and so `vim` proliferates in server environments, while `emacs`
has flexible user-interface customization options, making it more suitable in a
desktop environment.

Another text editor available on many systems out of the box is `nano`. To
avoid duels over the choice of text-editor, and still teach you a somewhat
ubiquitous tool, we decided to focus on `nano`.

To get started on the recreational activity of recovering `poem.txt`:

```
~$ nano poem.txt
```

Much like the shell, `nano` uses a text-based user interface (TUI). Unlike the
shell, `nano` relies to a greater extent on *keyboard shortcuts*, rather than
commands. Furthermore, the `nano` TUI is quite reminiscent of a classical
graphical user-interface (GUI). We believe that this makes `nano` more suitable
for beginners.

At the bottom of the TUI, `nano` shows a short reference of useful shortcuts:

```
  ^G Get Help      ^O Write Out     ^W Where Is     ...
  ^X Exit          ^R Read File     ^\ Replace      ...
```

Here, `^` indicates the `Ctrl` character. For instance, type `Ctrl+o` to save
(i.e., "write out") the file you are editing. `nano` will now prompt you:

```
  File Name to Write: poem.txt
```

Hit `Enter` to confirm and overwrite `poem.txt`. To exit `nano`, type `Ctrl+x`.

`vim` also uses a TUI by default, while `emacs` can be started in this mode
with the command-line argument `-nw` (i.e., no window system). So `vim` and
`emacs` can be used to similarly edit `poem.txt`, but they are far less
friendly to beginners.

A typical problem that beginning users have is how exit either `vim` or `emacs`
once they open them. In `vim`, you can press Esc to enter a so-called "command
mode", enter the command `:q` and press Enter. In `emacs`, you use the keyboard
sequence `Ctrl+x`, `Ctrl+c`. Figuring out how to edit and save files in either
`vim` or `emacs` is left as an exercise for the bored reader. Else, continue
with `nano`.

### Exercises

1. Open `poem.txt` in `nano`.

2. Cut out the first line and paste it (uncut) at the bottom of the poem. Save
the new file.

3. Determine the number of lines and characters in the poem using `nano`. How
many characters are there in the longest line?

4. Copy the entire poem beneath itself without doing this line-by-line. Hint:
use "Read File".

## `mv` and `&&` { #sec-shell-mv-and }

TODO: `||` and `exit`

`mv` can be used to move/rename files. It takes at least two command-line
arguments, the source file path and a target file path. If you supply more than
2 arguments, all files listed before the last argument will be moved to the
folder designated by the last argument.

`&&` can be used to chain commands together such that the second is executed if
and only if, the first one succeeds.

```
mv poem.txt poem.txt.long && mv poem.txt.long poem.txt
```

### Exercises

1. Create the directories `North America` and `South America` in your
home directory. Create a directory `America` and move all the
aforementioned directories into this one.

2. Remove the folder `America`.

3. Do exercises 3 and 4 above (relating to `nano`) using `wc`, `cat`, `>`,
`&&`, and `mv`. OBS! You can't read and write the same file in the same
command. For task 4, you will need to use a temporary file.

## Shell Scripts 101 { #sec-shell-shell-scripts }

TODO: `bash` and `sh` (also using `exit`)

Composing small utilities to form complicated commands is fun, but it is also
hard work. We can save our work by encoding a command into a so-called shell
script — a file containing shell commands. In effect, we are creating a utility
of our own.

Let's walk through creating a shell-script for doubling the contents of a file.

First, open a file `double.sh` in `nano`. The `.sh` extension follows the
convention that shell scripts should have the filename extensions `.sh`,
although this does not really make it a "shell script".

`double.sh`, as a command-line utility, will take a command line argument
(`$1`), regard it as a path to an existing file, `cat` this file twice into a
temporary file (`$1.double`), and if this succeeds, move `$1.double` to `$1`,
replacing the original file. Here, `$1` is a shell variable referring to the
first command-line argument. If no such argument is given, `$1` is an empty
string.

Write the following to `double.sh` using `nano`:

```
cat $1 $1 > $1.double && mv $1.double $1
```

Now, to run this shell script, pass it as an argument to the program `bash`:

```
~$ wc -l poem.txt
       4 poem.txt
~$ bash double.sh poem.txt
~$ wc -l poem.txt
       8 poem.txt
```

`double.sh` is still far from a conventional command-line utility. It is a lot
of work typing `bash double.sh` instead of just `double`. We will come back to
how you can do this later.

## `file` and `which` { #sec-shell-file-which }

In a Unix-like operating system, everything is a file. Furthermore, it is the
contents, or the metadata of a file (not e.g., a filename extension), that
determines the _type_ of a file.

The `file` utility exists to help users "guess" the type of a file. Its usage
is simple:

```
~$ file poem.txt
poem.txt: ASCII text
~$ file double.sh
double.sh: ASCII text
~$ file 1/
1/: directory
~$ file .
.: directory
```

When you type a program name in your shell, this program must exist as an
executable somewhere on your filesystem. You can use `which` to figure out what
a given program name resolves to.

In Unix-like operating systems it is conventional to have short names (aliases)
for more concrete programs. One such popular program is Python. Our server has
Python version 2.7 installed, but it suffices to type `python` to start it up.
The following sequence of `which` and `file` commands shows how we can figure
out the concrete executable behind "`python`":

```
$ which python
/usr/local/bin/python
~$ file /usr/local/bin/python
/usr/local/bin/python: symbolic link to python2
~$ which python2
/usr/local/bin/python2
~$ file /usr/local/bin/python2
/usr/local/bin/python2: symbolic link to python2.7
~$ which python2.7
/usr/local/bin/python2.7
~$ file /usr/local/bin/python2
/usr/local/bin/python2: symbolic link to python2.7
~$ file /usr/local/bin/python2.7
/usr/local/bin/python2.7: ELF 64-bit LSB executable ...
```

The last line indicates that we've reached the actual executable that gets
loaded into memory when we type `python` in our shell. Until then, we merely
follow so-called "symbolic links".

### Exercises

1. Which concrete executable does `sh` resolve to?

2. Which concrete executable does `bash` resolve to?

3. Which concrete executable does `which` resolve to?
